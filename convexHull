  // Does the algorithm get more efficient as the # of nodes increases?
  // You only need to iterate 3-4% of possible cycles with 10,000,000 nodes

{

  let nodes       = [];     //  All nodes
  let candidates  = [];     //  Possible hull nodes
  let hull        = [];     //  Only hull nodes

  let centre;               //  Point used to determine convexity

  let topLeft     = -1;
  let topRight    = -1;
  let bottomLeft  = -1;
  let bottomRight = -1;

  let purged      = false;

  let domain      = -1;
  let range       = -1;

  let nod0;
  let nod1;
  let nod2;

  let running         = false;
  let sorted          = false;

  let buffer          = 20;
  let candidateCount  = 0;
  let extent          = -Infinity;

  var radius          = Infinity;
  var diameter        = 10;

  // const limit   = 3163;  //  3163 squared is approx 10,000,000
  const limit     = 143;

  class node {
    
    constructor(n=0, x=-1, y=-1){

      this.id       = n;      //  nodes array index
      this.pid      = null;   //  candidate array list index

      this.x        = x;
      this.y        = y;

      this.next     = null;
      this.previous = null;

      this.hull     = true;   //  nodes are opt-out for the hull

      this.selected = false;

    }

    copy(pid){

      var nodeCopy=new node(this.id, this.x, this.y);

      nodeCopy.pid      = pid;

      nodeCopy.next     = this.next;
      nodeCopy.previous = this.previous;

      nodeCopy.hull     = this.hull;

      nodeCopy.selected = this.selected;

      return nodeCopy;

    }

  }

  function setup(){

    // frameRate(100);
    noCursor();

    "use strict"; 

    createCanvas(windowWidth-50, windowHeight-50);

    strokeJoin(BEVEL);

    if(width>height){ extent=height; }
    else            { extent=width;  }

    // diameter=extent-2*buffer;
    radius=diameter/2;

    loadNodes();

    centre=new node("C", width/2, height/2);

    nod0=candidates[0];

  }; 

  function swap(m,n){

    let temp=nodes[n];   
    nodes[n]=nodes[m];
    nodes[m]=temp;
    
  }

  function loadNodes(){
    
    let x         = -1;
    let y         = -1;
    
    let minX      = Infinity;
    let maxX      = 0;
    let minY      = Infinity;
    let maxY      = 0;

    let theta     = 0;

    let topLeftDist=Infinity;
    let topRightDist=Infinity;
    let bottomLeftDist=Infinity;
    let bottomRightDist=Infinity;

    for(let n=0; n<limit; n++){

      theta=random(0,360);
      radius=random(0,extent/2-buffer);

      // x=cos(theta)*radius+width/2;
      // y=sin(theta)*radius+height/2;

      x=round(random(buffer, width-buffer ));
      y=round(random(buffer, height-buffer));

      if(x<minX){ minX=x; }
      if(x>maxX){ maxX=x; }
      if(y<minY){ minY=y; }
      if(y>maxY){ maxY=y; }

      nodes.push(new node(n,x,y));

      let d=dist(0,0,nodes[n].x,nodes[n].y);

      if(d<topLeftDist     ){ topLeft=nodes[n];
                              topLeftDist=d;      }

      d=dist(width,0,nodes[n].x,nodes[n].y);

      if(d<topRightDist    ){ topRight=nodes[n];
                              topRightDist=d;     }

      d=dist(width,height,nodes[n].x,nodes[n].y);

      if(d<bottomRightDist){ bottomRight=nodes[n];
                             bottomRightDist=d;   }

      d=dist(0,height,nodes[n].x,nodes[n].y);

      if(d<bottomLeftDist ){ bottomLeft=nodes[n];
                             bottomLeftDist=d;    }
    }

    count=nodes.length;

    // Sort nodes for demo purposes
    if(sorted){

      for(let n=0; n<limit; n++){
        for(let m=0; m<limit; m++){
          
          if(nodes[n].y>nodes[m].y){
            swap(n,m);
          }

        }
      }

    }

  }

  let m=0;
  let n=0;
  
  let q1=false;
  let q2=false;
  let q3=false;
  let q4=false;
  
  let counter=0;

  function loadLinkedList(){

    let nod=candidates[0];

    function setNext(nod) {

      let min=Infinity;
      let index=-1;

      for(let n=0; n<candidates.length; n++){

        if(nod.id!=n &&
          candidates[n].selected==false){

          d=dist(candidates[n].x,
            candidates[n].y,
                 nod.x,
                 nod.y);

          if(d<min){
            min=d;
            index=n;
          }

        }

      }

      nod.next=candidates[index];

    }

    for(let n=0; n<candidates.length; n++){

      nod.pid=n;
      nod.selected=true;

      setNext(nod);

      if(nod.next!=null){
        nod.next.previous=nod;
      }
      else{
        nod.next=candidates[0];
        candidates[0].previous=nod;
      }

      nod=nod.next

    }

  }
  function calculateCandidates(){

    candidateCount=0;

    for(let n=0; n<nodes.length; n++){
      if(nodes[n].hull){
        nodes[n].pid=candidateCount;
        candidateCount++;
        candidates.push(nodes[n]);
      }
    }

  }
  // Eliminate Non-Hull nodes.
  function loadCandidates(){

    if(nodes[m].x > nodes[n].x &&
       nodes[m].y < nodes[n].y){  q1=true;  } //  Quadrant #1

    if(nodes[m].x < nodes[n].x &&
       nodes[m].y < nodes[n].y){  q2=true;  } //  Quadrant #2

    if(nodes[m].x < nodes[n].x &&
       nodes[m].y > nodes[n].y){  q3=true;  } //  Quadrant #3

    if(nodes[m].x > nodes[n].x &&
       nodes[m].y > nodes[n].y){  q4=true;  } //  Quadrant #4

    if(q1 && q2 && q3 && q4){

      nodes[n].hull=false;

      q1=false;
      q2=false;
      q3=false;
      q4=false;

      n++;

      if(n>floor(limit/10) &&
         sorted){ m=floor(n-limit/10); }
      else      { m=0                  }

      // print(n);
      counter++;
      // Point has been eliminated so exit loop
      
    }
    else{

      m++;
      
      if(m==nodes.length){        
        m=0
        n++;
      }

    }

    if(n==nodes.length){
      
      purged=true;      
      running=false;
      
      calculateCandidates();
      loadLinkedList();
      
      nod0=candidates[0];
      nod1=nod0.next;
      nod2=nod1.next;

      calculateHull();
    }

  }

  function drawNodes(){

    fill(255);
    noStroke();
    let r=0;

      for(let p=0; p<nodes.length; p++){

        if(nodes[p].hull){ fill(255,255,0); r=3; }
        else             { fill(255);       r=1; }

          ellipse(nodes[p].x, nodes[p].y, r, r);

          if(nodes[p].hull && purged){

            fill(255, 255, 255);
            textSize(16);
            text(nodes[p].pid,
                 nodes[p].x+5,
                 nodes[p].y-5);

          }

      }

  }

  function drawCandidates(){

    stroke(128);
    strokeWeight(1);
    fill( 64, 64, 64, 64);

    beginShape();

      let nod=candidates[0];

      for(let n=0; n<candidates.length; n++){

        if(nod.hull){

          vertex(nod.x, nod.y);
          
          nod=nod.next;

        }
        
      }

      vertex(nod.x,nod.y);

    endShape();

    // noStroke();
    // textSize(10);

    // for(let p=0; p<candidates.length; p++){

    //   if(candidates[p].hull){ fill(255, 255, 0, 255); }
    //   else                 { fill(255, 255, 0,  32); }

    //     ellipse(candidates[p].x, candidates[p].y, 5, 5);

    //   if(candidates[p].hull){
      
    //     fill(255, 255, 255);
    
    //      text(candidates[p].pid,
    //           candidates[p].x+5,
    //           candidates[p].y-5);
    //   }
    
    // }

  }

  function calculateHull(){

    nod1=nod0.next;
    nod2=nod1.next;

    function drawTriangles(){
      
      noStroke();
  
      fill(  0,  0,128,128);
  
        ellipse(centre.x, centre.y,
                20,       20);

      fill(128,  0,  0, 96);

        triangle(centre.x, centre.y,
                 nod0.x,   nod0.y,
                 nod1.x,   nod1.y);

      fill(  0,128,  0, 96);
  
        triangle(centre.x, centre.y,
                 nod1.x,   nod1.y,
                 nod2.x,   nod2.y);

      noFill();
  
      strokeWeight(0.5);
      stroke(255,255,255,255);

        triangle(centre.x, centre.y,
                 nod0.x,   nod0.y,
                 nod2.x,   nod2.y);
    }
    
    function triangleArea(p0,p1,p2){

      //  Heron's Formula
      let a=dist(p0.x, p0.y, p1.x, p1.y);
      let b=dist(p1.x, p1.y, p2.x, p2.y);
      let c=dist(p2.x, p2.y, p0.x, p0.y);

      let semi=(a+b+c)/2;
      
      return pow((semi*(semi-a)*(semi-b)*(semi-c)), 0.5);
          
    }
    function hullHit(centre,p0,p1,p2){

      // If the large triangle is smaller the sum of the other 2, the nodes are convex
      let largeTriangle  = triangleArea(centre,p0,p2);
      let smallTriangles = triangleArea(centre, p0, p1) + triangleArea(centre, p1, p2);

      return (largeTriangle>smallTriangles);

    }    
  
    drawTriangles();
    
    if(running){
      
      if(hullHit(centre,
                 nod0,
                 nod1,
                 nod2)){

        nod1.hull=false;
        nod1.next=null;
        nod1.previous=null;
        
        nod0.next=nod2;
        nod2.previous=nod0;

        nod0=nod0.previous;
      
      }
      else{
    
        nod0=nod0.next;
    
      }

    }
  
  }
  function drawCentre(){

    fill(0,128,0,128);
    noStroke();
  
      ellipse(centre.x,centre.y,diameter,diameter);

  }
  function drawGUI(){

    fill(16);
    noStroke();

      rect(10,10,width-10, height-10);

    fill(128);
    textSize(36);
    textAlign(CENTER,CENTER);
    
      if(!running){ text("Click to begin", centre.x, centre.y-100); }
      else        { text("Click to pause", centre.x, centre.y-100); }
      
  }
  function drawCursor(){

    noFill();
    stroke(212);

    if(running){ strokeWeight(1.5);    }
    else       { strokeWeight(0.5);    }

      line(       0, mouseY, mouseX-5, mouseY);
      line(mouseX+5, mouseY,    width, mouseY);

      line(mouseX,        0, mouseX, mouseY-5);
      line(mouseX, mouseY+5, mouseX, height);

      ellipse(mouseX,mouseY,10,10);

    if(running){
    
      textSize(24);
      fill(212);
      noStroke();

      textAlign(LEFT,BOTTOM);

        text("1", mouseX+20, mouseY-20);

      textAlign(RIGHT,BOTTOM);
      
        text("2", mouseX-20, mouseY-20);

      textAlign(RIGHT,TOP);
      
        text("3", mouseX-20, mouseY+20);
      
      textAlign(LEFT,TOP);
      
        text("4", mouseX+20, mouseY+20);
    }

  }  
  function draw(){

    push();

      translate(0.5,0.5);

        background(0);

        if(!purged && running){
          
          for(let n=0; n<floor(limit/10); n++){
            
            if(running){
              loadCandidates();              
            }

          }

        }

        noStroke();
        fill(128);
        textSize(24);
        textAlign(LEFT,TOP);

          text(count,10,10);

        drawGUI();

        if(candidates.length!=0){
          drawCandidates();
          calculateHull();
        }

        drawNodes();

        if(!purged && running){

          mouseX=nodes[n].x;
          mouseY=nodes[n].y;

          fill(16,50);
          noStroke();

          if(q1){ rect(nodes[n].x, 0, width-nodes[n].x, nodes[n].y);                 }
          if(q2){ rect(0, 0, nodes[n].x, nodes[n].y);                                }
          if(q3){ rect(0, nodes[n].y, nodes[n].x, height-nodes[n].y);                }
          if(q4){ rect(nodes[n].x, nodes[n].y, width-nodes[n].x, height-nodes[n].y); }

        }

        drawCentre();
        drawCursor();

    pop();

  }  

  function mouseClicked(){

    running=!running;

  }

  function doubleClicked(){

    print("doubleClicked");
  
  }

}

/*  
  *
+stackoverflow.com
+khanacademy.org
+codecogs.com/latex/eqneditor.php
+youtube.com
+mail.google.com
+bradsiemens.com
+processingjs.org
+processing.org
forum.processing.org
+wikipedia.org
+google.com
+w3schools.com
+touchmathematics.org
+desmos.com
+github.com
+emptyblack.com
+redblobgames.com
+dailymotion.com
+pistolslut.com
+latin-phrases.co.uk/quotes/beginning-end
+code.org
+natureofcode.com
+alssndro.github.io/trianglify-background-generator
+p5js.org
+google.ca
+projecteuler.net
+www.numberempire.com
+oeis.org
+math.stackexchange.com
+jasondavies.com
+developer.mozilla.org
+docs.oracle.com
+www.mathopenref.com
+alpha.editor.p5js.org
+en.wikibooks.org
+upload.wikimedia.org
+viterbipk12.usc.edu

*/
