  // Does the algorithm get more efficient as the # of nodes increases?
  // You only need to iterate 3-4% of possible cycles with 10,000,000 possibilities

  /*

    Nodes shape options
      - rectangular
      - circular
      ...

  */
  {

    var PRE_PROCESSING = {

      NONE:       0,
      OCTO:       1,
      QUAD:       2

    };
    var HULL_METHODS = {

      BUBBA:            0,
      GIFT_WRAP:        1,
      QUCK_HULL:        2,
      DIVIDE_CONQUER:   2,
      MONOTONE_CHAIN:   2,
      INCREMENTAL:      2,
      ULTIMATE_PLANAR:  2,
      CHANS_ALGORITHM:  2

    };

    let nodes           = [];     //  All nodes
    let candidates      = [];     //  Possible hull nodes
    let hull            = [];     //  Only hull nodes
  
    let centre;               //  Point used to determine convexity

    let purged          = false;
  
    let domain          = -1;
    let range           = -1;

    let nod0;
    let nod1;
    let nod2;
  
    let running         = false;
    let sorted          = false;
    let excludeOnLoad   = false;                 //  Nodes are eliminated while they are loaded

    let preprocessing   = PRE_PROCESSING.QUAD;
    let hullMethod      = HULL_METHODS.BUBBA;

    let buffer          = 20;
    let candidateCount  = -1;
    let extent          = -Infinity;
    let hullLength      = 0;

    let radius          = Infinity;
    let diameter        = 10;
  
    // let m=0;
    // let n=0;
    
    let q1              = false;
    let q2              = false;
    let q3              = false;
    let q4              = false;
    
    let quadrants       = [];
    let quadrantCount   = 8;  //  Change based on Pre-processing heuristic

    let thetaQuadrant   = -1;

    // let counter=0;

    let limit           = 500; //  3163 squared is approx 10,000,000
    
    let processCount    = 0;    //  # of comparisons conducted

    class node {
      
      constructor(n=0, x=-1, y=-1){
  
        this.id       = n;          //  node index
        this.cid      = null;       //  candidate index
  
        this.x        = x;          //  x coordinate
        this.y        = y;          //  y coordinate
  
        this.theta    = -Infinity;  //  Angle to the origin
        
        this.quadrant = -Infinity;  // cartesian quadrant 
        this.distance = -Infinity;  //  distance to the origin

        this.next     = null;       // linked list next
        this.previous = null;       // linked list previous
  
        this.hull     = true;       // nodes are opt-out for the hull

        this.selected = false;  

      }
  
      clone(cid){
  
        var nClone=new node(this.id, this.x, this.y);
  
        nClone.cid      = cid;
  
        nClone.next     = this.next;
        nClone.previous = this.previous;
  
        nClone.hull     = this.hull;
  
        nClone.selected = this.selected;
  
        return nClone;
  
      }
  
    }
  
    function setup(){

      noCursor();
  
      "use strict"; 
  
      createCanvas(windowWidth-50, windowHeight-50);
  
      strokeJoin(BEVEL);
  
      if(width>height){ extent=height; }
      else            { extent=width;  }
  
      // diameter=extent-2*buffer;
      radius=diameter/2;
  
      centre=new node("C", 0, 0);

    }; 

    { // Misc
        
      function calculateHullLength(){

        let cds=candidates;

        hullLength=0;

        if(cds.length!=0){

          for(let n=0; n<cds.length-1; n++){

            hullLength+=dist(cds[n].x,
                              cds[n].y,
                              cds[n+1].x,
                              cds[n+1].y);
          }

          hullLength+=dist(cds[0].x,
                            cds[0].y,
                            cds[cds.length-1].x,
                            cds[cds.length-1].y);
        }

      }

      function swap(m,n){
    
        let temp=n;   
        n=m;
        m=temp;
        
      }
      function sortByTheta(arr){
    
        for(let n=0; n<arr.length; n++){
          for(let m=0; m<arr.length; m++){
            
            if(arr[n].theta>arr[m].theta){
              
              let temp = arr[n];   
              arr[n]   = arr[m];
              arr[m]   = temp;
    
            }
    
          }
        }
  
      }
  
      function triangleArea(p0,p1,p2){
    
        //  Heron's Formula
        let a=dist(p0.x, p0.y, p1.x, p1.y);
        let b=dist(p1.x, p1.y, p2.x, p2.y);
        let c=dist(p2.x, p2.y, p0.x, p0.y);

        let semi=(a+b+c)/2;
        
        return pow((semi*(semi-a)*(semi-b)*(semi-c)), 0.5);
            
      }

      function hullHit(centre,p0,p1,p2){

        // If the large triangle is smaller the sum of the other 2, the nodes are convex
        let largeTriangle  = triangleArea(centre,p0,p2);
        let smallTriangles = triangleArea(centre, p0, p1) + triangleArea(centre, p1, p2);

        return (largeTriangle>smallTriangles);

      }
      
    }

    function setQuadrantOcto(n){

      let tq  = thetaQuadrant;
      let nod = nodes[n];
      let th  = nod.theta;
      let q   = -1;

      try{

        switch(true){

          case th >=  0     && th <= tq:      q=0; break;
          case th >= tq     && th <= 90:      q=1; break;
          case th >=  90    && th <= 180-tq:  q=2; break;
          case th >= 180-tq && th <= 180:     q=3; break;
          case th >= 180    && th <= 180+tq:  q=4; break;
          case th >= 180+tq && th <= 270:     q=5; break;
          case th >= 270    && th <= 360-tq:  q=6; break;
          case th >= 360-tq && th <= 360:     q=7; break;

          default:                  throw('Bad Quadrant');

        }

        nod.quadrant=q;

        if(nod.distance>quadrants[q].distance ){ quadrants[q]=nod; }

      }
      catch(err){
        print(err + " : " + th + " : " + n + " : " + q);
      }

    }
    function setQuadrantQuad(n){

      let th  = nodes[n].theta;
      let nod = nodes[n];
      let q   = -1;

      try{

        switch(true){

          case th <=  0 && th >  -90: q=0; break;
          case th <=-90 && th >=-180: q=1; break;
          case th >  90 && th <= 180: q=2; break;
          case th >=  0 && th <=  90: q=3; break;

          default:         throw('Bad Quadrant');

        }

        nod.quadrant=q;

        if(nod.distance>quadrants[q].distance ){ quadrants[q]=nod; }

      }
      catch(err){
        print(err + " : " + th + " : " + n + " : " + q);
      }

    } 
    function excludeNodeOcto(n){

      if(nodes[n].x<quadrants[0].x && //  x coordinates
         nodes[n].x<quadrants[1].x &&
         nodes[n].x<quadrants[6].x &&
         nodes[n].x<quadrants[7].x &&
         nodes[n].x>quadrants[2].x &&
         nodes[n].x>quadrants[3].x &&
         nodes[n].x>quadrants[4].x &&
         nodes[n].x>quadrants[5].x &&
         nodes[n].y>quadrants[4].y && // y coordinates
         nodes[n].y>quadrants[5].y &&
         nodes[n].y>quadrants[6].y &&
         nodes[n].y>quadrants[7].y &&
         nodes[n].y<quadrants[0].y &&
         nodes[n].y<quadrants[1].y &&
         nodes[n].y<quadrants[2].y &&
         nodes[n].y<quadrants[3].y){

        nodes[n].hull=false;

      }
      
    }
    function excludeNodeOctoTriangle(n){

      let th=nodes[n].theta;
      let q=nodes[n].quadrant;
      
    if(q<7){

      if(th>=quadrants[q].theta &&
         th<=quadrants[q+1].theta &&
         hullHit(centre,quadrants[q],nodes[n],quadrants[q+1])){

          // print(q + " : " + quadrants[q].theta + " : " + quadrants[q+1].theta);

         nodes[n].hull=false;

      }

    }
         return;

      // if(th>=quadrants[0].theta &&
      //    th<=quadrants[1].theta &&
      //    hullHit(centre,quadrants[0],nodes[n],quadrants[1])){

      //     nodes[n].hull=false;

      // }
      // else if(th>=quadrants[1].theta &&
      //         th<=quadrants[2].theta &&
      //         hullHit(centre,quadrants[1],nodes[n],quadrants[2])){

      //   nodes[n].hull=false;

      // }
      // else if(th>=quadrants[2].theta &&
      //         th<=quadrants[3].theta &&
      //         hullHit(centre,quadrants[2],nodes[n],quadrants[3])){

      //    nodes[n].hull=false;

      // }
      // else if(th>=quadrants[3].theta &&
      //         th<=quadrants[4].theta &&
      //         hullHit(centre,quadrants[3],nodes[n],quadrants[4])){

      //   nodes[n].hull=false;

      // }      
      // else if(th>=quadrants[4].theta &&
      //         th<=quadrants[5].theta &&
      //         hullHit(centre,quadrants[4],nodes[n],quadrants[5])){

      //   nodes[n].hull=false;

      // }
      // else if(th>=quadrants[5].theta &&
      //         th<=quadrants[6].theta &&
      //         hullHit(centre,quadrants[5],nodes[n],quadrants[6])){

      //   nodes[n].hull=false;

      // }
      // else if(th>=quadrants[6].theta &&
      //         th<=quadrants[7].theta &&
      //         hullHit(centre,quadrants[6],nodes[n],quadrants[7])){

      //   nodes[n].hull=false;

      // }
      // else if(th>=quadrants[7].theta &&
      //         hullHit(centre,quadrants[7],nodes[n],quadrants[0])){

      //   nodes[n].hull=false;

      // }
      // else if(th<=quadrants[0].theta &&
      //         hullHit(centre,quadrants[0],nodes[n],quadrants[7])){

      //   nodes[n].hull=false;

      // }      

    }
    function excludeNodeQuadTriangle(n){

      let th=nodes[n].theta;

      if(th<=quadrants[0].theta &&
         th>=quadrants[1].theta &&
         hullHit(centre,quadrants[0],nodes[n],quadrants[1])){

          nodes[n].hull=false;

      }
      else if(th>=quadrants[3].theta &&
              th<=quadrants[2].theta &&
              hullHit(centre,quadrants[2],nodes[n],quadrants[3])){

        nodes[n].hull=false;

      }
      else if(th>=quadrants[0].theta &&
              th<=quadrants[3].theta &&
              hullHit(centre,quadrants[0],nodes[n],quadrants[3])){

         nodes[n].hull=false;

      }
      else if(th<=quadrants[1].theta &&
              hullHit(centre,quadrants[1],nodes[n],quadrants[2])){

        nodes[n].hull=false;

      }
      else if(th>=quadrants[2].theta &&
              hullHit(centre,quadrants[1],nodes[n],quadrants[2])){

        nodes[n].hull=false;

      }

    }
    function excludeNodeQuad(n){

      if(nodes[n].x<quadrants[0].x && //  x coordinates
         nodes[n].x>quadrants[1].x &&
         nodes[n].x>quadrants[2].x &&
         nodes[n].x<quadrants[3].x &&
         nodes[n].y>quadrants[0].y && //  y coordinates
         nodes[n].y>quadrants[1].y &&
         nodes[n].y<quadrants[2].y &&
         nodes[n].y<quadrants[3].y){

        nodes[n].hull=false;

      }

    }

    let setQuadrant;
    let excludeNode;

    setQuadrant=setQuadrantOcto;
    excludeNode=excludeNodeOctoTriangle;

    function loadNodes(){
      
      let _x     = -1;
      let _y     = -1;

      let _minX  = Infinity;
      let _maxX  = 0;
      let _minY  = Infinity;
      let _maxY  = 0;

      push();
  
        translate(width/2,height/2);
          
          // Determine theta of the sloped corners
          thetaQuadrant=180/PI*atan2(height/2,width/2);

          // Set all nodes in the quadrants to the centre
          // this avoids having to check for undefined
          for(let n=0; n<quadrantCount; n++){
            quadrants[n]=centre;
          }

          for(let _n=0; _n<limit; _n++){

            _x=round(random(3*buffer-width/2, width/2-buffer   ));
            _y=round(random(buffer-height/2,  height/2-3*buffer));

            if(_x<_minX){ _minX=_x; }
            if(_x>_maxX){ _maxX=_x; }
            if(_y<_minY){ _minY=_y; }
            if(_y>_maxY){ _maxY=_y; }

            nodes.push(new node(_n,_x,_y));
            
            nodes[_n].distance = dist(0,0,_x,_y);
            nodes[_n].theta    = 180/PI*atan2(_y,_x);
            
            if(nodes[_n].theta<0){ nodes[_n].theta+=360; }

            setQuadrant(_n);

            // Include a flag for exclude on load
            if(excludeOnLoad){ excludeNode(_n); }

          }

          //  Set the domain and range of the nodes
          domain = abs(_maxX-_minX);
          range  = abs(_minY-_maxY);

      pop();
print(quadrants);
    }
  
    function loadLinkedList(){
  
      let nod=candidates[0];
  
      for(let n=0; n<candidates.length; n++){
  
        nod.cid=n;
        nod.selected=true;

        nod.next=candidates[n+1];
  
        if(nod.next!=null){
          nod.next.previous=nod;
        }
        else{
          nod.next=candidates[0];
          candidates[0].previous=nod;
        }
  
        nod=nod.next
  
      }
  
    }
    function setCandidates(){

      candidates=[];

      for(let n=0; n<limit; n++){

        if(nodes[n].hull){
          nodes[n].cid=candidates.length;
          candidates.push(nodes[n]);
        }

      }

      sortByTheta(candidates);

    }

    function loadCandidates(){

      for(let n=0; n<nodes.length; n++){

        excludeNode(n);

      }

      setCandidates();
      loadLinkedList();

      nod0=candidates[0];
      nod1=nod0.next;
      nod2=nod1.next;

      purged=true;      
      running=false;

    }
  
    function calculateHull(){
  // frameRate(10);
      nod1=nod0.next;
      nod2=nod1.next;

      if(running){
        
        if(hullHit(centre,
                   nod0,
                   nod1,
                   nod2)){
  
          nod1.hull=false;
          nod1.next=null;
          nod1.previous=null;
          
          nod0.next=nod2;
          nod2.previous=nod0;
  
          nod0=nod0.previous;

          setCandidates();
          return;
  
        }
        else{
      
          nod0=nod0.next;
      
        }
  
      }
    
    }

    { // GUI

      function drawAxis(){

        // Slices
        stroke(128,0,0,255);
        strokeWeight(1);

          line(centre.x, centre.y, 0,-height/2);
          line(centre.x, centre.y, 0, height/2);

          line(centre.x, centre.y,-width/2, 0);
          line(centre.x, centre.y, width/2, 0);
                  

      }

      function drawQuadrantsQuad(){

        let r=10;
  
        fill(0,20);
        stroke(128);
        strokeWeight(2);
  
        beginShape();
  
          for(let n=0; n<quadrants.length; n++){
  
            ellipse(quadrants[n].x, quadrants[n].y, 10, 10);
            
            vertex(quadrants[n].x, quadrants[n].y);
  
          }
  
        endShape(CLOSE);

        // Draw quadrant lines
        stroke(0,255,0,128);
        strokeWeight(0.5);

        for(let n=0; n<quadrants.length; n++){
          line(0,0,quadrants[n].x,quadrants[n].y);
        }
                  
      }
      function drawQuadrantsOcto(){

        // Slices
        stroke(128,0,0,128);
        strokeWeight(1);

          line(centre.x, centre.y, width/2, height/2);
          line(centre.x, centre.y,-width/2, height/2);
          
          line(centre.x, centre.y, width/2,-height/2);
          line(centre.x, centre.y,-width/2,-height/2);

        // Draw quadrant lines
        stroke(0,255,0,128);
            
          for(let n=0; n<quadrants.length; n++){
            line(0,0,quadrants[n].x,quadrants[n].y);
          }

      }        
      
      function drawCandidates(){
  
        //  Draw line connecting cadidates
        stroke(128,128);
        strokeWeight(2);
        fill(16,50);
  
        beginShape();
  
          for(let n=0; n<candidates.length; n++){
            vertex(candidates[n].x,candidates[n].y);
          }
  
        endShape(CLOSE);
  
        // Draw candidate nodes
        let r=3;
  
        noStroke();
  
        for(let n=0; n<candidates.length; n++){
  
          fill(255,255,0);
  
          ellipse(candidates[n].x,candidates[n].y,r,r);
  
          if(candidates[n].x<0){ textAlign(LEFT,BOTTOM);  }
          else                 { textAlign(RIGHT,BOTTOM); }
  
          let theta=candidates[n].theta;
  
          // if(theta<0){ theta+=360; }
  
          fill(255, 255, 255);
          textSize(10);

            text(round(theta) + " : " +
                 round(candidates[n].quadrant),
                 candidates[n].x+5,
                 candidates[n].y-5);
  
        }
  
      }
      function drawNodes(){
  
        let r=1;
  
        fill(255);
        noStroke();
  
          for(let n=0; n<nodes.length; n++){
  
            // if(!nodes[n].hull){
                
              ellipse(nodes[n].x, nodes[n].y, r, r);

            // }
  
          }
  
      }
      
      function drawGUI(){
        
        function drawBorder(){

          //  Border
          fill(16);
          noStroke();
          stroke(128);

            rect(-width/2,-height/2, width-1, height-1);

        }
        function drawOrigin(){
    
          fill(128,0,0,128);
          noStroke();
        
            ellipse(centre.x,centre.y,diameter,diameter);
      
        }

        background(0);

        fill(128);
        textSize(36);
        textAlign(CENTER,CENTER);
        
          // if(!running){ text("Click to begin", centre.x, centre.y-100); }
          // else        { text("Click to pause", centre.x, centre.y-100); }
        
        drawBorder();          
        drawAxis();
        drawQuadrants();
        drawOrigin();

        telemetry();

      }
      function drawCursor(){
    
        noFill();
        stroke(192);
    
        if(running){ strokeWeight(1.0); }
        else       { strokeWeight(0.5); }
    
          line(-width/2,         mouseY-height/2, mouseX-width/2-5, mouseY-height/2);
          line(mouseX-width/2+5, mouseY-height/2,          width/2, mouseY-height/2);
    
          line(mouseX-width/2,         -height/2, mouseX-width/2, mouseY-height/2-5);
          line(mouseX-width/2, mouseY-height/2+5, mouseX-width/2, height/2);
    
          ellipse(mouseX-width/2,mouseY-height/2,10,10);
    
          return;

          push();
    
            // translate(-width/2,-height/2);
            // scale(1,-1);
    
            textSize(12);
            textAlign(LEFT,BOTTOM);
            fill(128);
            noStroke();
    
              text(round(atan2(mouseY,mouseX)*180/PI),mouseX+10,mouseY-10);
    
          pop();

        if(running){
        
          textSize(24);
          fill(212);
          noStroke();
    
          textAlign(LEFT,BOTTOM);
    
            text("1", mouseX-width/2+20, mouseY-height/2-20);
    
          textAlign(RIGHT,BOTTOM);
          
            text("2", mouseX-width/2-20, mouseY-height/2-20);
    
          textAlign(RIGHT,TOP);
          
            text("3", mouseX-width/2-20, mouseY-height/2+20);
          
          textAlign(LEFT,TOP);
          
            text("4", mouseX-width/2+20, mouseY-height/2+20);
        }
    
      }  

      function telemetry(){

        calculateHullLength();

        fill(128);
        noStroke();
        textSize(16);
        textAlign(LEFT,BOTTOM);

        let cl =candidates.length;
        let nl = nodes.length;

        let row1=processCount + " : " + pow(limit,2) + " : " + nf(processCount/pow(limit,2)*100,1,2) + "%";
        let row2=cl + " : " + nl + " : " + nf(cl/nl*100,1,2) + "%";

          text(row1,-width/2+20, height/2-30);
          text(row2,-width/2+20, height/2-10);

        textSize(12);

          text("Hull Length: " + round(hullLength),-width/2+200, height/2-10);
          
        // Domain and Range
        let dr="Domain: " + domain + " - Range:  " + range;

          text(dr,-width/2+400, height/2-10);

      }
      function drawTriangles(){
        
        noStroke();
  
        fill(128,  0,  0, 96);
  
          triangle(centre.x, centre.y,
                   nod0.x,   nod0.y,
                   nod1.x,   nod1.y);
  
        fill(  0,128,  0, 96);
    
          triangle(centre.x, centre.y,
                   nod1.x,   nod1.y,
                   nod2.x,   nod2.y);
  
        noFill();
    
        strokeWeight(0.5);
        stroke(255,255,255,255);
  
          triangle(centre.x, centre.y,
                   nod0.x,   nod0.y,
                   nod2.x,   nod2.y);
      }

      let drawQuadrants;

      drawQuadrants=drawQuadrantsQuad;

    }

    function draw(){
      
      if(nodes.length==0){
        loadNodes();
      }

      push();
  
        translate(width/2+0.5,height/2+0.5);

          if(!purged){

            loadCandidates();              
  
          }

          drawGUI();

          if(candidates.length!=0){
            calculateHull();
            drawTriangles();
          }

          drawNodes();
          drawCandidates();

          drawCursor();

          textSize(16);
          fill(255,0,0);
          noStroke();

          for(let n=0; n<quadrants.length; n++){
            text(n + " : " + round(quadrants[n].theta),quadrants[n].x,quadrants[n].y);
          }
      pop();

    }  
  
    function mouseClicked(){
  
      running=!running;
  
      if(keyIsDown(CONTROL)){
        print(candidates);
      }
      
    }
  
    function doubleClicked(){
  
      print("doubleClicked");
    print(dist(0,0,width,0));
    }
  
  }

      // Eliminate Non-Hull nodes.
      function loadCandidatesSlow(){
  
        if(nodes[m].x > nodes[n].x &&
           nodes[m].y < nodes[n].y){  q1=true;  } //  Quadrant #1
    
        if(nodes[m].x < nodes[n].x &&
           nodes[m].y < nodes[n].y){  q2=true;  } //  Quadrant #2
    
        if(nodes[m].x < nodes[n].x &&
           nodes[m].y > nodes[n].y){  q3=true;  } //  Quadrant #3
    
        if(nodes[m].x > nodes[n].x &&
           nodes[m].y > nodes[n].y){  q4=true;  } //  Quadrant #4
    
        if(q1 && q2 && q3 && q4){
    
          nodes[n].hull=false;
    
          q1=false;
          q2=false;
          q3=false;
          q4=false;
    
          n++;
    
          if(n>floor(limit/10) &&
             sorted){ m=floor(n-limit/10); }
          else      { m=0                  }
    
          // print(n);
          counter++;
          // Point has been eliminated so exit loop
          
        }
        else{
    
          m++;
          
          if(m==nodes.length){        
            m=0
            n++;
          }
    
        }
    
        if(n==nodes.length){
          
          purged=true;      
          running=false;
          
          countCandidates();
          loadLinkedList();
          
          nod0=candidates[0];
          nod1=nod0.next;
          nod2=nod1.next;
    
          calculateHull();
    
        }
    
      }

/*  

*
+stackoverflow.com
+khanacademy.org
+codecogs.com/latex/eqneditor.php
+youtube.com
+mail.google.com
+bradsiemens.com
+processingjs.org
+processing.org
forum.processing.org
+wikipedia.org
+google.com
+w3schools.com
+touchmathematics.org
+desmos.com
+github.com
+emptyblack.com
+redblobgames.com
+dailymotion.com
+pistolslut.com
+latin-phrases.co.uk/quotes/beginning-end
+code.org
+natureofcode.com
+alssndro.github.io/trianglify-background-generator
+p5js.org
+google.ca
+projecteuler.net
+www.numberempire.com
+oeis.org
+math.stackexchange.com
+jasondavies.com
+developer.mozilla.org
+docs.oracle.com
+www.mathopenref.com
+alpha.editor.p5js.org
+en.wikibooks.org
+upload.wikimedia.org
+viterbipk12.usc.edu

*/
