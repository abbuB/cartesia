  // Does the algorithm get more efficient as the # of nodes increases?
  // You only need to iterate 3-4% of possible cycles with 10,000,000 nodes

  let points    = [];     //  All points
  let potential = [];     //  Possible hull points
  let hull      = [];     //  Only hull points

  let centre;             //  Point used to determine convexity

  let domain    = -1;
  let range     = -1;

  let nod0;
  let nod1;
  let nod2;

  let running   = false;

  let buffer    = 20;

  let extent    = -Infinity;

  var radius    = Infinity;
  var diameter  = Infinity;

  const limit   = 13163;  //  3163 squared is approx 10,000,000
  // const limit   = 1000;

  class node {
    
    constructor(n=0, x=-1, y=-1){

      this.id       = n;      //  points array index
      this.pid      = null;   //  potential array list index

      this.x        = x;
      this.y        = y;

      this.next     = null;
      this.previous = null;

      this.hull     = true;   //  Points are opt-out for the hull

      this.selected = false;

    }

    copy(pid){

      var nodeCopy=new node(this.id, this.x, this.y);

      nodeCopy.pid      = pid;

      nodeCopy.next     = this.next;
      nodeCopy.previous = this.previous;

      nodeCopy.hull     = this.hull;

      nodeCopy.selected = this.selected;

      return nodeCopy;

    }

  }

  function loadPoints() {
    
    let x         = -1;
    let y         = -1;
    
    let minX      = Infinity;
    let maxX      = 0;
    let minY      = Infinity;
    let maxY      = 0;
    
    let theta     = 0;
    
    for (let n=0; n<limit; n++) {
      
      theta=random(0,360);
      radius=random(0,extent/2-buffer);
      
      // x=cos(theta)*radius+width/2;
      // y=sin(theta)*radius+height/2;

      x=round(random(buffer, width-buffer ));
      y=round(random(buffer, height-buffer));
      
      if(x<minX){ minX=x; }
      if(x>maxX){ maxX=x; }
      if(y<minY){ minY=y; }
      if(y>maxY){ maxY=y; }

      points.push(new node(n,x,y));

    }

  }

  // Eliminate Non-Hull points.
  function loadPotential() {

    potential=[];
    
    let counter=0;

    let q1=false;
    let q2=false;
    let q3=false;
    let q4=false;

    for(var n=0; n<points.length; n++){
      for(var m=0; m<points.length; m++){

        if(points[m].x > points[n].x &&
           points[m].y < points[n].y){
          q1=true;
        }

        if(points[m].x < points[n].x &&
           points[m].y < points[n].y){
          q2=true;
        }

        if(points[m].x < points[n].x &&
           points[m].y > points[n].y){
          q3=true;
        }

        if(points[m].x > points[n].x &&
           points[m].y > points[n].y){
          q4=true;
        }

        if(q1 && q2 && q3 && q4){

          points[n].hull=false;

          // Point has been eliminated so exit loop
          break;

        }

        counter++;

      }

      q1=false;
      q2=false;
      q3=false;
      q4=false;

    }

    //  Create copies in the potential array
    for(let n=0; n<points.length; n++){

      if(points[n].hull){
        potential.push(points[n].copy(potential.length-1));
      }

    }

    // How many comparisons were needed?
    print("Comparisons:      " + counter + " : " + (limit*limit) + " : " + nf((counter / (limit * limit) * 100), 1, 2) + "%");
    print("Potential length: " + potential.length);

  }

  function loadLinkedList() {

    let nod=potential[0];

    function setNext(nod) {

      let min=Infinity;
      let index=-1;

      for(let n=0; n<potential.length; n++){

        if(nod.id!=n &&
           potential[n].selected==false){

          d=dist(potential[n].x,
                 potential[n].y,
                 nod.x,
                 nod.y);

          if(d<min){
            min=d;
            index=n;
          }

        }

      }

      nod.next=potential[index];

    }

    for(let n=0; n<potential.length; n++){

      nod.pid=n;
      nod.selected=true;

      setNext(nod);

      if(nod.next!=null){
        nod.next.previous=nod;
      }
      else{
        nod.next=potential[0];
        potential[0].previous=nod;
      }

      nod=nod.next

    }

  }
  
  function setup(){

    "use strict"; 

    createCanvas(windowWidth-50, windowHeight-50);

    strokeJoin(BEVEL);

    if(width>height){ extent=height; }
    else            { extent=width;  }

    diameter=extent-2*buffer;
    radius=diameter/2;

    for(var n=0; n<1; n++){ // Loop was used to test loading speed
      loadPoints();
      loadPotential();
      loadLinkedList();
    }  

    centre=new node("C", width/2, height/2);

    nod0=potential[0];

  };  

  function drawPoints() {

    fill(255);
    noStroke();

      for(let p=0; p<points.length; p++){
        ellipse(points[p].x, points[p].y, 1, 1);
      }

  }

  function drawPotential(){

    stroke(128);
    strokeWeight(1);
    fill( 64, 64, 64, 64);

    beginShape();

      let nod=nod0;

      for(let n=0; n<potential.length; n++){

        if(nod.hull){
          
          vertex(nod.x, nod.y);
          
          nod=nod.next;

        }
        
      }

      vertex(nod.x,nod.y);

    endShape();

    noStroke();
    textSize(10);

    for(let p=0; p<potential.length; p++){

      if(potential[p].hull){ fill(255, 255, 0, 255); }
      else                 { fill(255, 255, 0,  32); }

        ellipse(potential[p].x, potential[p].y, 5, 5);

      if(potential[p].hull){
      
        fill(255, 255, 255);
    
         text(potential[p].pid,
              potential[p].x+5,
              potential[p].y-5);    
      }
    
    }

  }

  function calculateHull(){

    nod1=nod0.next;
    nod2=nod1.next;

    function drawTriangles(){
      
      noStroke();
  
      fill(  0,  0,128,128);
  
        ellipse(centre.x, centre.y,
                20,       20);

      fill(128,  0,  0, 96);

        triangle(centre.x, centre.y,
                 nod0.x,   nod0.y,
                 nod1.x,   nod1.y);

      fill(  0,128,  0, 96);
  
        triangle(centre.x, centre.y,
                 nod1.x,   nod1.y,
                 nod2.x,   nod2.y);

      noFill();
  
      strokeWeight(0.5);
      stroke(255,255,255,255);

        triangle(centre.x, centre.y,
                 nod0.x,   nod0.y,
                 nod2.x,   nod2.y);
    }
    
    function triangleArea(p0,p1,p2){

      //  Heron's Formula
      let a=dist(p0.x, p0.y, p1.x, p1.y);
      let b=dist(p1.x, p1.y, p2.x, p2.y);
      let c=dist(p2.x, p2.y, p0.x, p0.y);

      let semi=(a+b+c)/2;
      
      return pow((semi*(semi-a)*(semi-b)*(semi-c)), 0.5);
          
    }
    function hullHit(centre,p0,p1,p2){

      // If the large triangle is smaller the sum of the other 2, the points are convex
      let largeTriangle  = triangleArea(centre,p0,p2);
      let smallTriangles = triangleArea(centre, p0, p1) + triangleArea(centre, p1, p2);

      return (largeTriangle>smallTriangles);

    }    
  
    drawTriangles();
    
    if(running){
      
      if(hullHit(centre,
                 nod0,
                 nod1,
                 nod2)){

        nod1.hull=false;
        nod1.next=null;
        nod1.previous=null;
        
        nod0.next=nod2;
        nod2.previous=nod0;

        // potential.splice(nod1.pid,1);
        
        nod0=nod0.previous;
      
      }
      else{
    
        nod0=nod0.next;
    
      }

    }
  
  }
  function drawCentre(){

    fill(0);
    stroke(0,64,0,128);
    strokeWeight(3);
  
      ellipse(centre.x,centre.y,diameter,diameter);

  }
  function drawGUI(){


    noStroke();
    fill(128);
    textSize(36);
    textAlign(CENTER,CENTER);
    
      if(!running){ text("Click to begin", centre.x, centre.y-100); }
      else        { text(potential.length, centre.x, centre.y-100); }
      
  }
  function draw(){

    push();

      translate(0.5,0.5);

        background(16);

        drawPoints();
        drawPotential();
        calculateHull();
        
        drawGUI();

    pop();

  }  

  function mouseClicked(){

    running=!running;

  }

  function doubleClicked(){

    print("doubleClicked");
  
  }
