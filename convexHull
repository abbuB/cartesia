  // Does the algorithm get more efficient as the # of nodes increases?
  // You only need to iterate 3-4% of possible cycles with 10,000,000 possibilities

  /*

    Nodes shape options
      - rectangular
      - circular
      ...

  */
  {

    var PRE_PROCESSING = {

      NONE:       0,
      OCTO:       1,
      QUAD:       2

    };
    var HULL_METHODS = {

      BUBBA:            0,
      GIFT_WRAP:        1,
      QUCK_HULL:        2,
      DIVIDE_CONQUER:   2,
      MONOTONE_CHAIN:   2,
      INCREMENTAL:      2,
      ULTIMATE_PLANAR:  2,
      CHANS_ALGORITHM:  2

    };

    let nodes           = [];     //  All nodes
    let candidates      = [];     //  Possible hull nodes
    let hull            = [];     //  Only hull nodes
  
    let centre;               //  Point used to determine convexity

    let purged          = false;
  
    let domain          = -1;
    let range           = -1;

    let nod0;
    let nod1;
    let nod2;
  
    let running         = false;
    let sorted          = true;
    
    let preprocessing   = PRE_PROCESSING.QUAD;
    let hullMethod      = HULL_METHODS.BUBBA;

    let buffer          = 20;
    let candidateCount  = 0;
    let extent          = -Infinity;
  
    let radius          = Infinity;
    let diameter        = 10;
  
    // let m=0;
    // let n=0;
    
    let q1              = false;
    let q2              = false;
    let q3              = false;
    let q4              = false;
    
    let quadrants       = [];

    let thetaQuadrant   = -1;

    // let counter=0;

    let limit           = 3000; //  3163 squared is approx 10,000,000
  
    class node {
      
      constructor(n=0, x=-1, y=-1){
  
        this.id       = n;          //  node index
        this.cid      = null;       //  candidate index
  
        this.x        = x;          //  x coordinate
        this.y        = y;          //  y coordinate
  
        this.theta    = -Infinity;  //  Angle to the origin
        
        this.quadrant = -Infinity;  // cartesian quadrant 
        this.distance = -Infinity;  //  distance to the origin

        this.next     = null;       // linked list next
        this.previous = null;       // linked list previous
  
        this.hull     = true;       // nodes are opt-out for the hull

        this.selected = false;  

      }
  
      clone(cid){
  
        var nClone=new node(this.id, this.x, this.y);
  
        nClone.cid      = cid;
  
        nClone.next     = this.next;
        nClone.previous = this.previous;
  
        nClone.hull     = this.hull;
  
        nClone.selected = this.selected;
  
        return nClone;
  
      }
  
    }
  
    function setup(){

      noCursor();
  
      "use strict"; 
  
      createCanvas(windowWidth-50, windowHeight-50);
  
      strokeJoin(BEVEL);
  
      if(width>height){ extent=height; }
      else            { extent=width;  }
  
      // diameter=extent-2*buffer;
      radius=diameter/2;
  
      centre=new node("C", 0, 0);

      loadNodes();
  
    }; 
  
    function swap(m,n){
  
      let temp=n;   
      n=m;
      m=temp;
      
    }
    function sortByAngle(arr){

      for(let n=0; n<limit; n++){
        for(let m=0; m<limit; m++){

          if(arr[n].theta>arr[m].theta){
            swap(arr[n],arr[m]);
          }

        }
      }

    }
    
    function setOctoQuadrant(n){

      let tq  = thetaQuadrant;
      let nod = nodes[n];
      let th  = nod.theta;
      let q   = -1;

      try{

        switch(true){

          case th >=  0     && th < tq:        q=0; break;
          case th >= tq     && th < 90:        q=1; break;
          case th >=  90    && th < ( 180-tq): q=2; break;
          case th <= 180    && th > ( 180-tq): q=3; break;
          case th >=-180    && th < (-180+tq): q=4; break;
          case th >=-180+tq && th < -90:       q=5; break;
          case th >= -90    && th < -tq:       q=6; break;
          case th <=   0    && th > -tq:       q=7; break;

          default:                  throw('Bad Quadrant');

        }

        nod.quadrant=q;

        if(nod.distance>quadrants[q].distance ){ quadrants[q]=nod; }

      }
      catch(err){
        print(err + " : " + th + " : " + n + " : " + q);
      }

    }
    function setQuadrant(n){

      let th  = nodes[n].theta;
      let nod = nodes[n];
      let q   = -1;

      try{

        switch(true){

          case th <=  0 && th >  -90: q=0; break;
          case th <=-90 && th >=-180: q=1; break;
          case th >  90 && th <= 180: q=2; break;
          case th >=  0 && th <=  90: q=3; break;

          default:        throw('Bad Quadrant');

        }

        nod.quadrant=q;

        if(nod.distance>quadrants[q].distance ){ quadrants[q]=nod; }

      }
      catch(err){
        print(err + " : " + th + " : " + n + " : " + q);
      }

    } 

    function excludeNode(n){

      switch(preprocessing){

        case PRE_PROCESSING.OCTO:
      
          if(nodes[n].x<quadrants[0].x && //  x coordinates
             nodes[n].x<quadrants[1].x &&
             nodes[n].x<quadrants[6].x &&
             nodes[n].x<quadrants[7].x &&
             nodes[n].x>quadrants[2].x &&
             nodes[n].x>quadrants[3].x &&
             nodes[n].x>quadrants[4].x &&
             nodes[n].x>quadrants[5].x &&
             nodes[n].y>quadrants[4].y && // y coordinates
             nodes[n].y>quadrants[5].y &&
             nodes[n].y>quadrants[6].y &&
             nodes[n].y>quadrants[7].y &&
             nodes[n].y<quadrants[0].y &&
             nodes[n].y<quadrants[1].y &&
             nodes[n].y<quadrants[2].y &&
             nodes[n].y<quadrants[3].y){

            nodes[n].hull=false;

          }
        
          break;

        case PRE_PROCESSING.QUAD:

            if(nodes[n].x<quadrants[0].x && // x coordinates
               nodes[n].x>quadrants[1].x &&
               nodes[n].x>quadrants[2].x &&
               nodes[n].x<quadrants[3].x &&
               nodes[n].y>quadrants[0].y && // y coordinates
               nodes[n].y>quadrants[1].y &&
               nodes[n].y<quadrants[2].y &&
               nodes[n].y<quadrants[3].y){

            nodes[n].hull=false;

          }

          break;

        default:  
      
      }

    }

    let setNodeQuadrant;
    
    setNodeQuadrant=setQuadrant;

    function loadNodes(){
      
      let x     = -1;
      let y     = -1;

      let minX  = Infinity;
      let maxX  = 0;
      let minY  = Infinity;
      let maxY  = 0;

      let theta = -1;

      push();
  
        translate(width/2,height/2);
          
          // Determine theta of the sloped corners
          thetaQuadrant=180/PI*atan2(height/2,width/2);

          // Set all nodes in the quadrants to the centre
          // this avoids having to check for undefined
          for(let n=0; n<4; n++){
            quadrants[n]=centre;
          }

          for(let n=0; n<limit; n++){

            x=round(random(3*buffer-width/2, width/2-buffer   ));
            y=round(random(buffer-height/2,  height/2-3*buffer));

            if(x<minX){ minX=x; }
            if(x>maxX){ maxX=x; }
            if(y<minY){ minY=y; }
            if(y>maxY){ maxY=y; }

            nodes.push(new node(n,x,y));
            
            nodes[n].distance=dist(0,0,x,y);

            nodes[n].theta=180/PI*atan2(nodes[n].y,nodes[n].x);

            setNodeQuadrant(n);
            excludeNode(n);

        }

        domain = abs(maxX-minX);
        range  = abs(minY-maxY);

        // print(domain + " : " + range);

      pop();

      // if(sorted){ sortByAngle(nodes); }

    }
  
    function setCandidateCount(){

      for(let n=0; n<nodes.length; n++){

        if(nodes[n].hull){
          candidateCount++;
        }

      }

      print(candidateCount);

    }
    function loadLinkedList(){
  
      let nod=candidates[0];
  
      function setNext(nod){
  
        let min=Infinity;
        let index=-1;
  
        for(let n=0; n<candidates.length; n++){
  
          if(nod.id!=n &&
             candidates[n].selected==false){
  
            d=dist(candidates[n].x,
                   candidates[n].y,
                   nod.x,
                   nod.y);
  
            if(d<min){
              min=d;
              index=n;
            }
  
          }
  
        }
  
        nod.next=candidates[index];
  
      }
  
      for(let n=0; n<candidates.length; n++){
  
        // nod.cid=n;
        nod.selected=true;
  
        // setNext(nod);
        nod.next=candidates[n+1];
  
        if(nod.next!=null){
          nod.next.previous=nod;
        }
        else{
          nod.next=candidates[0];
          candidates[0].previous=nod;
        }
  
        nod=nod.next
  
      }
  
    }
    function addCandidates(){

      let count=0;
      candidates=[];

      for(let n=0; n<limit; n++){

        if(nodes[n].hull){
          nodes[n].cid=count;
          count++;
          candidates.push(nodes[n]);
        }

      }

      sortByTheta(candidates);

    }
    
    let processCount=0;

    function loadCandidates(){

      function isInteriorOcto(n){

        if(nodes[n].x<quadrants[0].x &&
          nodes[n].x<quadrants[1].x &&
          nodes[n].x<quadrants[6].x &&
          nodes[n].x<quadrants[7].x &&
          nodes[n].x>quadrants[2].x &&
          nodes[n].x>quadrants[3].x &&
          nodes[n].x>quadrants[4].x &&
          nodes[n].x>quadrants[5].x &&

          nodes[n].y>quadrants[4].y &&
          nodes[n].y>quadrants[5].y &&
          nodes[n].y>quadrants[6].y &&
          nodes[n].y>quadrants[7].y &&
          nodes[n].y<quadrants[0].y &&
          nodes[n].y<quadrants[1].y &&
          nodes[n].y<quadrants[2].y &&
          nodes[n].y<quadrants[3].y){

          nodes[n].hull=false;

        }
        
      }
      function isInteriorQuad(n){

        if(nodes[n].x<quadrants[0].x && // x coordinates
          nodes[n].x>quadrants[1].x &&
          nodes[n].x>quadrants[2].x &&
          nodes[n].x<quadrants[3].x &&
          nodes[n].y>quadrants[0].y && // y coordinates
          nodes[n].y>quadrants[1].y &&
          nodes[n].y<quadrants[2].y &&
          nodes[n].y<quadrants[3].y){

          nodes[n].hull=false;

        }

      }
      for(let n=0; n<limit; n++){
        
        isInteriorQuad(n);

        // for(let m=0; m<limit; m++){

          // if(nodes[m].x > nodes[n].x &&
          //    nodes[m].y < nodes[n].y){  q1=true;  } //  Quadrant #1
  
          // if(nodes[m].x < nodes[n].x &&
          //    nodes[m].y < nodes[n].y){  q2=true;  } //  Quadrant #2
  
          // if(nodes[m].x < nodes[n].x &&
          //    nodes[m].y > nodes[n].y){  q3=true;  } //  Quadrant #3
  
          // if(nodes[m].x > nodes[n].x &&
          //    nodes[m].y > nodes[n].y){  q4=true;  } //  Quadrant #4
 
          // if(q1 && q2 && q3 && q4){

          //   nodes[n].hull=false;
  
          //   q1=false;
          //   q2=false;
          //   q3=false;
          //   q4=false;
          //   // print(m);
          //   processCount+=m;
          //   break;

          // }
  
        // }
      }

      purged=true;      
      running=false;
      
      addCandidates();
      print(candidates.length);
      loadLinkedList();

      nod0=candidates[0];
      nod1=nod0.next;
      nod2=nod1.next;
  
      // calculateHull();
  
    }
    // Eliminate Non-Hull nodes.
    function loadCandidatesSlow(){
  
      if(nodes[m].x > nodes[n].x &&
         nodes[m].y < nodes[n].y){  q1=true;  } //  Quadrant #1
  
      if(nodes[m].x < nodes[n].x &&
         nodes[m].y < nodes[n].y){  q2=true;  } //  Quadrant #2
  
      if(nodes[m].x < nodes[n].x &&
         nodes[m].y > nodes[n].y){  q3=true;  } //  Quadrant #3
  
      if(nodes[m].x > nodes[n].x &&
         nodes[m].y > nodes[n].y){  q4=true;  } //  Quadrant #4
  
      if(q1 && q2 && q3 && q4){
  
        nodes[n].hull=false;
  
        q1=false;
        q2=false;
        q3=false;
        q4=false;
  
        n++;
  
        if(n>floor(limit/10) &&
           sorted){ m=floor(n-limit/10); }
        else      { m=0                  }
  
        // print(n);
        counter++;
        // Point has been eliminated so exit loop
        
      }
      else{
  
        m++;
        
        if(m==nodes.length){        
          m=0
          n++;
        }
  
      }
  
      if(n==nodes.length){
        
        purged=true;      
        running=false;
        
        countCandidates();
        loadLinkedList();
        
        nod0=candidates[0];
        nod1=nod0.next;
        nod2=nod1.next;
  
        calculateHull();
  
      }
  
    }
  
    function drawNodes(){
      
      let r=10;

      fill(0,20);
      stroke(128);
      strokeWeight(2);

      beginShape();

        for(let n=0; n<quadrants.length; n++){
          
          // r=quadrants[n].distance/50;

          ellipse(quadrants[n].x, quadrants[n].y, 10, 10);

// textSize(16);
// textAlign(RIGHT,BOTTOM);
// text(round(quadrants[n].theta), quadrants[n].x, quadrants[n].y-10);

          vertex(quadrants[n].x, quadrants[n].y);

        }

      endShape(CLOSE);

      
      fill(255, 255, 255);
      textSize(10);

      // text(round(nodes[p].theta) + " : " +
      //      round(nodes[p].quadrant),
      //      nodes[p].x+5,
      //      nodes[p].y-5);

      // return;

      fill(255);
      noStroke();
      // let r=0;
  r=1;
  
        for(let p=0; p<limit; p++){
  
          if(nodes[p].hull){ fill(255,255,0); r=3; }
          else             { fill(255);       r=1; }
          
          // r=nodes[p].distance/60;
          // if(random()<0.1){
            ellipse(nodes[p].x, nodes[p].y, r, r);
          // }
  
            if(nodes[p].hull && purged){
              
              ellipse(nodes[p].x, nodes[p].y, r, r);

              fill(255, 255, 255);
              textSize(10);

              if(nodes[p].x<0){ textAlign(LEFT,BOTTOM);  }
              else            { textAlign(RIGHT,BOTTOM); }

              let theta=nodes[p].theta;

              if(theta<0){ theta+=360; }

              // text(round(theta) + " : " +
              //      round(nodes[p].quadrant),
              //      nodes[p].x+5,
              //      nodes[p].y-5);
            }

        }

    }
    function sortByTheta(arr){
  
      for(let n=0; n<arr.length; n++){
        for(let m=0; m<arr.length; m++){
          
          if((arr[n].theta+0)>(arr[m].theta+0)){
            
            let temp = arr[n];   
            arr[n]   = arr[m];
            arr[m]   = temp;
  
          }
  
        }
      }
  
      
    }
    function drawCandidates(){
  
      // sortByTheta(candidates);
  frameRate(10);
      stroke(128);
      strokeWeight(1);
      fill( 64, 64, 64, 64);
  
      let nod=candidates[0];
  
      beginShape();
  
        for(let n=0; n<candidates.length; n++){
  
          if(nod.hull){
  
            vertex(nod.x, nod.y);
            
            nod=nod.next;
  
          }
          
        }
  
        vertex(nod.x,nod.y);
  
      endShape();
  
    }
  
    function calculateHull(){
  // frameRate(10);
      nod1=nod0.next;
      nod2=nod1.next;
  
      function drawTriangles(){
        
        noStroke();
  
        fill(128,  0,  0, 96);
  
          triangle(centre.x, centre.y,
                   nod0.x,   nod0.y,
                   nod1.x,   nod1.y);
  
        fill(  0,128,  0, 96);
    
          triangle(centre.x, centre.y,
                   nod1.x,   nod1.y,
                   nod2.x,   nod2.y);
  
        noFill();
    
        strokeWeight(0.5);
        stroke(255,255,255,255);
  
          triangle(centre.x, centre.y,
                   nod0.x,   nod0.y,
                   nod2.x,   nod2.y);
      }
      
      function triangleArea(p0,p1,p2){
  
        //  Heron's Formula
        let a=dist(p0.x, p0.y, p1.x, p1.y);
        let b=dist(p1.x, p1.y, p2.x, p2.y);
        let c=dist(p2.x, p2.y, p0.x, p0.y);
  
        let semi=(a+b+c)/2;
        
        return pow((semi*(semi-a)*(semi-b)*(semi-c)), 0.5);
            
      }
  
      function hullHit(centre,p0,p1,p2){
  
        // If the large triangle is smaller the sum of the other 2, the nodes are convex
        let largeTriangle  = triangleArea(centre,p0,p2);
        let smallTriangles = triangleArea(centre, p0, p1) + triangleArea(centre, p1, p2);
  
        return (largeTriangle>smallTriangles);
  
      }    
    
      drawTriangles();
      
      if(running){
        
        if(hullHit(centre,
                   nod0,
                   nod1,
                   nod2)){
  
          nod1.hull=false;
          nod1.next=null;
          nod1.previous=null;
          
          nod0.next=nod2;
          nod2.previous=nod0;
  
          nod0=nod0.previous;
                    
          // candidates.splice(nod1.id,1);
          addCandidates();
          return;
  
        }
        else{
      
          nod0=nod0.next;
      
        }
  
      }
    
    }
    function drawCentre(){
  
      fill(128,0,0,128);
      noStroke();
    
        ellipse(centre.x,centre.y,diameter,diameter);
  
    }
    function drawGUI(){
  
      fill(16);
      noStroke();
      stroke(128);

        rect(-width/2,-height/2, width-1, height-1);
  
      fill(128);
      textSize(36);
      textAlign(CENTER,CENTER);
      
        // if(!running){ text("Click to begin", centre.x, centre.y-100); }
        // else        { text("Click to pause", centre.x, centre.y-100); }
        
    }
    function drawCursor(){
  
      noFill();
      stroke(212);
  
      if(running){ strokeWeight(1.5); }
      else       { strokeWeight(0.5); }
  
        line(-width/2,         mouseY-height/2, mouseX-width/2-5, mouseY-height/2);
        line(mouseX-width/2+5, mouseY-height/2,          width/2, mouseY-height/2);
  
        line(mouseX-width/2,         -height/2, mouseX-width/2, mouseY-height/2-5);
        line(mouseX-width/2, mouseY-height/2+5, mouseX-width/2, height/2);
  
        ellipse(mouseX-width/2,mouseY-height/2,10,10);
  
        push();
  
          translate(-width/2,-height/2);
          // scale(1,-1);
  
          textSize(12);
          textAlign(LEFT,BOTTOM);
          fill(128);
          noStroke();
  
            text(round(atan2(mouseY,mouseX)*180/PI),mouseX+10,mouseY-10);
  
        pop();
  
      if(running){
      
        textSize(24);
        fill(212);
        noStroke();
  
        textAlign(LEFT,BOTTOM);
  
          text("1", mouseX-width/2+20, mouseY-height/2-20);
  
        textAlign(RIGHT,BOTTOM);
        
          text("2", mouseX-width/2-20, mouseY-height/2-20);
  
        textAlign(RIGHT,TOP);
        
          text("3", mouseX-width/2-20, mouseY-height/2+20);
        
        textAlign(LEFT,TOP);
        
          text("4", mouseX-width/2+20, mouseY-height/2+20);
      }
  
    }  
    function draw(){
  
      push();
  
        translate(width/2+0.5,height/2+0.5);
        // scale(1,-1);
  
          background(0);
  
          if(!purged){
            
            // for(let n=0; n<floor(limit/10); n++){
              
              // if(running){
                loadCandidates();              
              // }
  
            // }
  
          }
  
          noStroke();
          fill(128);
          textSize(24);
          textAlign(LEFT,TOP);
  
            // text(count,10,10);
  
          drawGUI();
  
          // Slices
          stroke(128,0,0);
          strokeWeight(1);

            // line(centre.x, centre.y, width/2, height/2);
            // line(centre.x, centre.y,-width/2, height/2);
            
            // line(centre.x, centre.y, width/2,-height/2);
            // line(centre.x, centre.y,-width/2,-height/2);

            // line(centre.x, centre.y, 0,-height/2);
            // line(centre.x, centre.y, 0, height/2);

            // line(centre.x, centre.y,-width/2+buffer, 0);
            // line(centre.x, centre.y, width/2-buffer, 0);

          stroke(0,255,0,128);
          
          for(let n=0; n<quadrants.length; n++){
            line(0,0,quadrants[n].x,quadrants[n].y);
          }

          if(candidates.length!=0){
            drawCandidates();
            calculateHull();
          }
  
          drawNodes();
  
          // if(!purged && running){
  
          //   mouseX=nodes[n].x;
          //   mouseY=nodes[n].y;
  
          //   fill(16,50);
          //   noStroke();
  
          //   if(q1){ rect(nodes[n].x, 0, width-nodes[n].x, nodes[n].y);                 }
          //   if(q2){ rect(0, 0, nodes[n].x, nodes[n].y);                                }
          //   if(q3){ rect(0, nodes[n].y, nodes[n].x, height-nodes[n].y);                }
          //   if(q4){ rect(nodes[n].x, nodes[n].y, width-nodes[n].x, height-nodes[n].y); }
  
          // }
  
          // drawCentre();
          drawCursor();
  
          // Origin
          if(running){
  
            drawCentre();
  
          }
  
          fill(128);
          noStroke();
          textSize(16);
          textAlign(LEFT,BOTTOM);
  
          let cl =candidates.length;
          let nl = nodes.length;

          let row1=processCount + " : " + pow(limit,2) + " : " + nf(processCount/pow(limit,2)*100,1,2) + "%";
          let row2=cl + " : " + nl + " : " + nf(cl/nl*100,1,2) + "%";

            text(row1,-width/2+20, height/2-30);
            text(row2,-width/2+20, height/2-10);

            // ellipse(width/2,height/2,20,20);
            // ellipse(0,0,20,20);

      pop();
  
    }  
  
    function mouseClicked(){
  
      running=!running;
  
      if(keyIsDown(CONTROL)){
        print(candidates);
      }
      
    }
  
    function doubleClicked(){
  
      print("doubleClicked");
    
    }
  
  }

/*  

*
+stackoverflow.com
+khanacademy.org
+codecogs.com/latex/eqneditor.php
+youtube.com
+mail.google.com
+bradsiemens.com
+processingjs.org
+processing.org
forum.processing.org
+wikipedia.org
+google.com
+w3schools.com
+touchmathematics.org
+desmos.com
+github.com
+emptyblack.com
+redblobgames.com
+dailymotion.com
+pistolslut.com
+latin-phrases.co.uk/quotes/beginning-end
+code.org
+natureofcode.com
+alssndro.github.io/trianglify-background-generator
+p5js.org
+google.ca
+projecteuler.net
+www.numberempire.com
+oeis.org
+math.stackexchange.com
+jasondavies.com
+developer.mozilla.org
+docs.oracle.com
+www.mathopenref.com
+alpha.editor.p5js.org
+en.wikibooks.org
+upload.wikimedia.org
+viterbipk12.usc.edu

*/
