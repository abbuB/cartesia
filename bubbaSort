{

  let values      = [];

  let limit     = 600;
  let counter   = 0;
  let score     = 0;

  let min       = Infinity;
  let max       =-Infinity;

  let N         = 1;
  let i         = 1;
  let j         = 0;
  let index     = 0;

  const gap     =-1;

  let running   = false;

  let startTime = 0;
  let stopTime  = 0;
  let elapsed   = 0;

  const SORT_METHODS = {

    BUBBA:      "Bubba",
    MERGE:      "Merge",
    BUBBLE:     "Bubble",
    INSERTION:  "Insertion",
    SELECTION:  "Selection",
    GNOME:      "Gnome",
    RADIX:      "Radix"

  };

  class data {

    constructor(n=round(random(10,400)), x=0, y=0, w=100, h=100, min=0, max=100, sort=SORT_METHODS.BUBBLE){

      this.n          = n;

      this.x          = x;
      this.y          = y;
      this.w          = w;
      this.h          = h;

      this.values     = [];

      this.min        = min;
      this.max        = max;

      this.sortMethod = sort;

      this.dataCursor = 0;

      this.selected   = false;

    }

    increment(){
      
      this.valuesCursor++;
      
      if(this.valuesCursor==this.limit){
        this.valuesCursor=0;
      }

    }
    decrement(){
      
      this.valuesCursor--;

      if(this.valuesCursor==-1){
        this.valuesCursor=this.limit-1;
      }

    }
    copy(pid){

      var valuesCopy=new (this.id, this.x, this.y);

      nodeCopy.pid      = pid;

      nodeCopy.next     = this.next;
      nodeCopy.previous = this.previous;

      nodeCopy.hull     = this.hull;

      nodeCopy.selected = this.selected;

      return nodeCopy;

    }
    draw(){

      push();

        translate(this.x+0.5,this.y+0.5);
        
        //  Border
        strokeWeight(0.5);
        stroke(0);
        fill(232);

          rect(0,0,this.w,this.h);

        let x;
        let h;
        let w=(this.w-20)/this.n;

        noFill();
        strokeWeight(w);
        stroke(128,0,0,128);
        
        for(let i=0; i<this.n; i++){

          x=10+i*w;
          h=this.h/this.max*this.values[i]-20;

          stroke(255-h,0,0);

          line(x+w/2, this.h-10,
               x+w/2, this.h-h-10);

        }

        stroke(128,128);
        strokeWeight(3);

          line(8, this.h-8, this.w-8, this.h-8);

        textSize(24);
        textAlign(LEFT,TOP);
        noStroke();
        fill(0,56,0);

          text(this.sortMethod,5,5);

        textSize(12);
        textAlign(RIGHT,TOP);

          text(this.n,this.w-5,5);

      pop();

    }
    load(){

      // if(isRandom){

        this.values=[];

        for(let n=0; n<this.n; n++){
          this.values.push(random(this.min,this.max));
        }

      // }
      // else{
      //   print("Non-random data");
      // }

    }

  }


// print(random(100,200));
  function swap(m,n){

    let temp=values[n];   
    values[n]=values[m];
    values[m]=temp;
    
  }

  function swap2(m,n){

    let temp=n;   
    n=m;
    m=temp;

  }

  function shuffleArray(arr){

    for(let n=arr.length-1; n>0; n--){
      const m = floor(random()*(n+1));
      [arr[n], arr[m]] = [arr[m], arr[n]];
    }

  }

  function loadValues(){
    
    values=[];

    for(let n=0; n<limit; n++){
      // values[n]=n/2;
      values[n]=random(0,350);
    }

    shuffleArray(values);

  }
  function setLimits(){
    
    let value=null;
    
    let minIndex=0;
    let maxIndex=0;

    min=Infinity;
    max=-Infinity;

    //  Find max and min values
    for(let n=0; n<limit; n++){

      value=values[n];

      if(value>max){ max=value; maxIndex=n; }
      if(value<min){ min=value; minIndex=n; }

    }

    // Place max and min value
    swap(0,       minIndex);
    swap(limit-1, maxIndex);

  }

  let bubbaData;
  
  function refresh(){

    values=[];

    loadValues();
    setLimits();

    bubbaData0 = new data(100, 10, 10,500,250,100,300);
    bubbaData0.sortMethod=SORT_METHODS.INSERTION;

    bubbaData1 = new data(200,520, 10,500,250,100,300);
    bubbaData1.sortMethod=SORT_METHODS.MERGE;

    bubbaData2 = new data(300, 10,270,500,250,100,300);
    bubbaData2.sortMethod=SORT_METHODS.BUBBA;

    bubbaData3 = new data(400,520,270,500,250,100,300);
    bubbaData3.sortMethod=SORT_METHODS.RADIX;

    bubbaData4 = new data(50, 10,530,500,250,100,300);
    bubbaData4.sortMethod=SORT_METHODS.GNOME;

    bubbaData5 = new data(20,520,530,500,250,100,300);
    bubbaData5.sortMethod=SORT_METHODS.SELECTION;

    bubbaData0.load();
    bubbaData1.load();
    bubbaData2.load();
    bubbaData3.load();
    bubbaData4.load();
    bubbaData5.load();

  }
  function setup(){

    noCursor();

    frameRate(200);
    
    createCanvas(windowWidth-20, 790);

    noStroke();
    strokeCap(SQUARE);
    noFill();

    refresh();
    
  }
  function calculateScore(){

    score=1;

    for(let n=0; n<values.length-1; n++){

      if(values[n]<=values[n+1]){
        score++;
      }

    }

  }

  var ec=1;

  function gnomeSort(n, arr){

    let i = 0;
    
    while(i<n){

      if(i==0 || arr[i-1]<=arr[i]){
        
        i++;

      }
      else {
        
        let tmp=arr[i];
        arr[i]=arr[i-1];
        arr[--i]=tmp;

      }

    }

  }
  function selectionSort(){

    /* a[0] to a[aLength-1] is the array to sort */
    let i;
    let j;
    // let length=limit; // initialise to a's length

    /* advance the position through the entire array */
    /*   (could do i < aLength-1 because single element is also min element) */
    for(i=0; i<limit-1; i++){

        /* find the min element in the unsorted a[i .. aLength-1] */

        /* assume the min is the first element */
        let jMin=i;

        /* test against elements after i to find the smallest */
        for(j=i+1; j<limit; j++){

            /* if this element is less, then it is the new minimum */
            if (values[j]<values[jMin]){
                /* found new minimum; remember its index */
                jMin=j;
            }

        }

        if(jMin!=i){
          swap(i, jMin);
        }

    }

  }

  function mergeSort(arr) {

    // No need to sort the array if the array only has one element or empty
    if(arr.length<=1){
      return arr;
    }

    // In order to divide the array in half, we need to figure out the middle
    const middle=Math.floor(arr.length/2);
  
    // This is where we will be dividing the array into left and right
    const left = arr.slice(0, middle);
    const right = arr.slice(middle);
  
    // Using recursion to combine the left and right
    return merge( mergeSort(left), mergeSort(right) );

  }
  
  // Merge the two arrays: left and right
  function merge(left,right){

    let arr=[];
    let leftIndex=0;
    let rightIndex=0;
  
    // We will concatenate values into the resultArray in order
    while(leftIndex<left.length &&
          rightIndex<right.length){

      if(left[leftIndex]<right[rightIndex]){

        arr.push(left[leftIndex]);
        leftIndex++; // move left array cursor

      }
      else{
        
        arr.push(right[rightIndex]);
        rightIndex++; // move right array cursor

      }

    }
  
    // We need to concat to the resultArray because there will be one element left over after the while loop
    return arr.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));

  }

  // function bubbaSort(){

  //   ec++; //  Expansion coefficient

  //   if(ec==100){ ec=1; }
  // print(ec);
  //   function expand(){

  //     let temp=[];

  //     for(let n=0; n<limit*ec; n++){
        
  //       if(n%ec==0){ temp[n]=values[n/ec]; }
  //       else       { temp[n]=gap;        }

  //     }

  //     limit=temp.length;

  //     values=[];

  //     arrayCopy(temp,values);

  //   }
  //   function collapse(){

  //     let temp=[];
      
  //     for(let n=0; n<values.length; n++){

  //       if(values[n]!=gap){ temp.push(values[n]); }

  //     }

  //     limit=temp.length;
      
  //     values=[];

  //     arrayCopy(temp,values);

  //   }

  //   // for(let i=0; i<1; i++){

  //     // if(N==1){
  //       // expand();
  //     // }

  //     // Iterate and place values as percentage of max
  //     for(let n=1; n<limit-1; n++){

  //       N=n;

  //       index=constrain(ceil(values[N]/max*limit), 1, limit-2);
  //       // index=floor((values[n]/max)*limit);

  //       // if(values[index]==gap){

  //         if(values[N]-values[index]<0.05*max){
  //           index-=3;
            
  //           if(index<1){ index=1; }

  //         }

  //         // if(values[N]>values[N+1]){
  //           swap(N, index);
  //         // }

  //       // }

  //       N++;

  //       N%=limit;

  //       if(N==limit-2){ N==1; }
  //       if(N==0      ){ N=1;  }

  //     }

  //     // if(N==limit-1){
  //       collapse();
  //     // }

  //     calculateScore();

  //     // if(score>=0.94*limit){
  //     //   running=false;
  //     // }

  //   // }

  // };

  function bubbaSort(){

    // for(let i=0; i<1; i++){

    let temp=[];
    let factor=1;

      temp.length=1;
      
      // Iterate and place values as percentage of max
      for(let n=0; n<values.length; n++){

        index=round(values[n]);

        // print(index + " : " + round(lerp(min,max,index/limit)));

        while(temp[index+limit*factor]!=undefined){
          
          factor++;
          
          if(factor>10){
            print(factor);
          }

        }
        
        temp[index+limit*factor]=values[n];

        factor=1;

      }

      var temp2=[];

      for(let n=0; n<temp.length; n++){
        if(temp[n]!=undefined){
          temp2.push(temp[n]);
        }
      }

    arrayCopy(temp2,values);


    let limits=[];

    // Recombine groups
    for(let n=0; n<values.length; n++){

      if(values[n+1]<values[n]){

        limits.push(n);

      }

    }

    // for(let n=0; n<limits.length; n++){
      merge(values);
    // }

  running=false;

  };

  function bubbleSort(){

    var length = values.length-1;

    for(var i=0; i<length; i++){ //Number of passes    
      for(var j=0; j<(length-i-1); j++){ //Notice that j < (length - i)

        //Compare the adjacent positions
        if (values[j]>values[j+1]){

          swap(j, j+1);
  N++;

        }
      }
    }
    
  }

  // function bubbleSort(){

  //   if(running){

  //     if(values[j]>values[j+1]){
  //       swap(j, j+1);
  //     }

  //     if(j>limit-i-2){
  //       j=0;
  //       i++;
  //     }
  //     else{
  //       j++;
  //     }
      
  //   }

  // }

  function insertionSort(){

    let len = values.length;
    
    for(var i=1; i<len; i++){

      var tmp=values[i]; //Copy of the current element. 
      
      //  Check through the sorted part and compare with the number in tmp.
      //  If large, shift the number
      for(var j=i-1; j>=0 && (values[j]>tmp); j--){

        //  Shift the number
        values[j+1]=values[j];
        N++;
      }
      
      //  Insert the copied number at the correct position
      //  in sorted part.
      values[j+1]=tmp;
      
    }

  }

  function drawvalues(){
    
    let h=-1;
    let w=(width-40)/limit;
    let x=0;
    let y=400;

    noFill();
    strokeWeight(w-1);
  stroke(128);
    for(let n=0; n<limit; n++){

      // if(n%2==0){ stroke(164); }
      // else      { stroke(96);  }
      
      // if(n%2==0){ stroke(255-values[n]/height*128); }
      // else      { stroke(values[n]/height*128+64);  }
      

      if(n==0     ||
        n==limit-1){
        // stroke(255,0,0);
      }

      if(n==N){ stroke(255,  0,  0); }
      // if(n==i){ stroke(255,255,  0); }
      // if(n==j){ stroke(  0,255,  0); }

      if(values[n]>values[n+1] &&
        n<limit-1){
        stroke(192,0,0);
      }
      else{
        stroke(128);
      }

      h=values[n]+20;
      x=n*w+20;

      line(x, y-h, x, y);

    }

    strokeWeight(0.5);
    stroke(0);

      line(20,         height-values[0]-20,
          limit*w+20, height-values[limit-1]-20);

  }

  function drawCursor(){

    push();

      translate(0.5,0.5);

        noFill();
        stroke(64);
        strokeWeight(0.5);    

          line(       0, mouseY, mouseX-5, mouseY);
          line(mouseX+5, mouseY,    width, mouseY);

          line(mouseX,        0, mouseX, mouseY-5);
          line(mouseX, mouseY+5, mouseX, height);

          ellipse(mouseX,mouseY,10,10);

    pop();

  }

  function draw(){

    background(220);

  //   if(running){

  //     // loadValues();
  //     // setLimits();

  //     startTime=millis();

  //       // bubbaSort();

  //       values=mergeSort(values);

  //       // gnomeSort(limit,values);
  //       // bubbleSort();
  //       // values.reverse();

  //       // selectionSort();
  //       // bubbaSort();

  //       // values.sort((a, b) => a - b);
  //       // values.sort();
  //       // insertionSort();

  //     stopTime=millis();

  //     elapsed=stopTime-startTime;

  //     // running=false;

  //     print(values.length    + " : " +
  //        nf(startTime,1,3) + " : " +
  //        nf(stopTime, 1,3) + " : " +
  //        nf(elapsed,  1,3));

  //   }

  //   drawvalues();
  //   calculateScore();

  //   if(score>=0.99*limit){
  //     running=false;
  //   }

  //   // noStroke();
  //   // fill(128);

  //   // text(nf(startTime,1,0) + " : " +
  //   //      nf(stopTime,1,0) + " : " +
  //   //      elapsed,
  //   //      10,15);



  //   // print(counter);



  // // values.reverse();

  //   // if(counter<2){ bubbaSort();         }
  //   // else         { bubbleSort(values); }

  //   noStroke();
  //   fill(128,0,0);
  //   textSize(16);
  //   textAlign(LEFT,TOP);
    
  //     // text(values.length,20,10);

  //     text("Score: " + score + " / " + limit,20,10);
  //     text(round(score/limit*100)+"%",20,30);
  //     text(N,20,50);

    bubbaData0.draw();
    bubbaData1.draw();
    bubbaData2.draw();
    bubbaData3.draw();
    bubbaData4.draw();
    bubbaData5.draw();

    drawCursor();

  }
  function mouseMoved(){

    // let i=round((mouseX-20)/((windowWidth-40)/limit));

    // print(values[i]);

  }
  function mouseClicked(){

    running=!running;

  }

}
