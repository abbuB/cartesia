{

  // let values    = [];

  // let limit     = 600;
  let counter   = 0;
  let score     = 0;

  // let min       = Infinity;
  // let max       =-Infinity;

  let N         = 1;
  let i         = 1;
  let j         = 0;
  let index     = 0;

  const gap     =-1;

  let running   = false;

  let startTime = 0;
  let stopTime  = 0;
  let elapsed   = 0;

  const SORT_METHODS = {

    BUBBA:      "Bubba",
    MERGE:      "Merge",
    BUBBLE:     "Bubble",
    INSERTION:  "Insertion",
    SELECTION:  "Selection",
    GNOME:      "Gnome",
    RADIX:      "Radix"

  };

  let bubbaData0;
  let bubbaData1;
  let bubbaData2;
  let bubbaData3;
  let bubbaData4;
  let bubbaData5;

  class number {

    constructor(n=0, index=-1){
      
      this.value  = n;

      this.index  = index;

    }

  };

  class data {

    constructor(n=round(random(10,400)), x=0, y=0, w=100, h=100, min=0, max=100, sort=SORT_METHODS.BUBBLE){

      this.n          = n;

      this.x          = x;
      this.y          = y;
      this.w          = w;
      this.h          = h;

      this.i          = 0;
      this.j          = 0;

      this.values     = [];

      this.min        = min;
      this.max        = max;

      this.sortMethod = sort;

      this.dataCursor = 0;

      this.selected   = false;

      this.running    = true;

      this.load();

    }
    load(){

      let p=this;

      function setLimits(){
    
        let value=null;
        
        let minIndex=0;
        let maxIndex=0;
    
        let minVal=Infinity;
        let maxVal=-Infinity;

        //  Find max and min values
        for(let n=0; n<p.n; n++){
    
          value=p.values[n];
    
          if(value>maxVal){ maxVal=value; maxIndex=n; }
          if(value<minVal){ minVal=value; minIndex=n; }
    
        }
    
        // Place max and min value
        p.swap(0,                 minIndex);
        p.swap(p.values.length-1, maxIndex);
    
      }

      for(let n=0; n<p.n; n++){
        p.values.push(random(p.min,p.max));
      }

      setLimits();

    }
    increment(){
      
      this.j++;

      this.valuesCursor++;
      
      if(this.valuesCursor==this.limit){
        this.valuesCursor=0;
      }

    }
    decrement(){
      
      this.valuesCursor--;

      if(this.valuesCursor==-1){
        this.valuesCursor=this.limit-1;
      }

    }
    copy(pid){

      var valuesCopy=new (this.id, this.x, this.y);

      nodeCopy.pid      = pid;

      nodeCopy.next     = this.next;
      nodeCopy.previous = this.previous;

      nodeCopy.hull     = this.hull;

      nodeCopy.selected = this.selected;

      return nodeCopy;

    }
    swap(m,n){

      let temp=this.values[n];   
      this.values[n]=this.values[m];
      this.values[m]=temp;
      
    }
    randomizeValues(){

      for(let n=0; n<this.values.length; n++) {
        this.swap(n, round(random(this.values.length-1)));
      }
  
    };

    sort(){

      let p=this;

      function bubbaSort(){

        let arr=[];

        arr[0]=[p.values[0]];
        arr[p.values.length-1]=[p.values[p.values.length-1]];

        for(let n=1; n<p.values.length-1; n++){

          let index=round(norm(p.values[n], p.min, p.max)*p.n);

          if(arr[index]==undefined){
            arr[index]=[p.values[n]];
          }
          else{
            arr[index].push(p.values[n]);
          }

        }

        let newArray=[];

        for(let n=0; n<arr.length; n++){

          if(arr[n]!=undefined){

            for(let index=0; index<arr[n].length; index++){

              newArray.push(arr[n][index]);

            }

          }
        }

        arrayCopy(newArray,p.values);

        running=false;

        function getCount(){
        
          let count=0;

          for(let n=0; n<p.values.length-1; n++){

            if(p.values[n]>p.values[n+1]){
              count++;
            }

          }

          return count;

        }

        while(getCount()>0){

          print(getCount());

          for(let n=0; n<p.values.length-1; n++){

            if(p.values[n]>p.values[n+1]){
              p.swap(n,n+1);
            }

          }

        }

      };      
      function bubbleSort(){

        if(p.values[p.j]>p.values[p.j+1]){
  
          p.swap(p.j, p.j+1);
          // print(this.i+":"+this.j);
        }
  
        p.j++;
  
        if(p.j>p.n-1){
          
          p.j=0;
          p.i++;
  
          if(p.i>p.n-1){
            p.i=0;
            p.j=0;
            running=false;
            p.randomizeValues();
          }

        }    
  
      }
      function gnomeSort(){};
      function insertionSort(){

        let vals=p.values;

        if(vals[p.j+1]<vals[p.j]){

          p.swap(p.j+1,p.j);

        }

        if(p.j==0){
          p.i++;
          p.j=p.i-1;          
        }
        else{
          p.j--;
        }

        if(p.i==vals.length){
          p.i=1;
          p.j=1;
          p.randomizeValues();
        }

      };
      function mergeSort(){};
      function radixSort(){};
      function selectionSort(){};      

      switch(this.sortMethod){

        case SORT_METHODS.BUBBA:      bubbaSort();      break;
        case SORT_METHODS.BUBBLE:     bubbleSort();     break;
        case SORT_METHODS.GNOME:      gnomeSort();      break;
        case SORT_METHODS.INSERTION:  insertionSort();  break;
        case SORT_METHODS.MERGE:      mergeSort();      break;
        case SORT_METHODS.RADIX:      radixSort();      break;
        case SORT_METHODS.SELECTION:  selectionSort();  break;

        default:                                        break;

      }

    }
    draw(){

      let p=this;

      function border(){

        strokeWeight(0.5);
        stroke(96);
        fill(48);

          rect(0,0,p.w,p.h,2);
          
      }      
      function gui(){

        //  Graph
        let x;
        let h;
        let w=(p.w-20)/p.n;

        noFill();
        strokeWeight(w);
        stroke(128,0,0,128);
        
          for(let i=0; i<p.n; i++){

            x=10+i*w+w/2;
            h=p.values[i]/p.max*(p.h-20);

            stroke(lerp(0,164,p.values[i]/p.max),0,0);

            line(x, p.h-10,
                 x, p.h-10-h);

          }

stroke(128);
strokeWeight(1);

          let min=p.values[0]/p.max*(p.h-20);
          let max=p.values[p.values.length-1]/p.max*(p.h-20);

          if(min==NaN){ min = p.h-10; print(min + " : " + max); }
          if(max==NaN){ max = p.h-p.max-10; }

          line(10,     p.h-min-10,
               p.w-10, p.h-max-10);

        //  Bottom line
        stroke(128,128);
        strokeWeight(3);

          line(8, p.h-8, p.w-8, p.h-8);
        
        //  Details
        textSize(24);
        textAlign(LEFT,TOP);
        noStroke();
        fill(128,128,0);

          text(p.sortMethod,5,5);
  
        textSize(12);
        textAlign(RIGHT,TOP);

          text(p.n,p.w-5,5);

      }
      push();

        translate(p.x+0.5,p.y+0.5);
        
          border();
          gui();

      pop();

      if(running){
        this.sort();
      }

    }

  }

  function swap(m,n){

    let temp=values[n];   
    values[n]=values[m];
    values[m]=temp;
    
  }

  function swap2(m,n){

    let temp=n;   
    n=m;
    m=temp;

  }

  function shuffleArray(arr){

    for(let n=arr.length-1; n>0; n--){
      const m = floor(random()*(n+1));
      [arr[n], arr[m]] = [arr[m], arr[n]];
    }

  }

  function loadValues(){
    
    values=[];

    for(let n=0; n<limit; n++){
      // values[n]=n/2;
      values[n]=random(0,350);
    }

    shuffleArray(values);

  }
  function setLimits(){
    
    let value=null;
    
    let minIndex=0;
    let maxIndex=0;

    min=Infinity;
    max=-Infinity;

    //  Find max and min values
    for(let n=0; n<limit; n++){

      value=values[n];

      if(value>max){ max=value; maxIndex=n; }
      if(value<min){ min=value; minIndex=n; }

    }

    // Place max and min value
    swap(0,       minIndex);
    swap(limit-1, maxIndex);

  }

  function refresh(){

    // values=[];

    // loadValues();
    // setLimits();

    bubbaData0 = new data(100, 10, 10,500,350, 0,300,SORT_METHODS.BUBBA    );
    bubbaData1 = new data( 20,520, 10,500,350,40,300,SORT_METHODS.INSERTION);
    bubbaData2 = new data( 30, 10,380,500,350,90,300,SORT_METHODS.BUBBLE   );
    bubbaData3 = new data( 50,520,380,500,350,23,300,SORT_METHODS.INSERTION);

    // bubbaData4 = new data(50, 10,530,500,250,100,300,SORT_METHODS.GNOME);
    // bubbaData5 = new data(20,520,530,500,250,100,300,SORT_METHODS.RADIX);

    // bubbaData0.load();
    // bubbaData1.load();
    // bubbaData2.load();
    // bubbaData3.load();
    // bubbaData4.load();
    // bubbaData5.load();

  }
  function setup(){

    noCursor();

    createCanvas(windowWidth-20, 790);

    noStroke();
    strokeCap(SQUARE);
    noFill();

    refresh();
    
  }
  function calculateScore(){

    score=1;

    for(let n=0; n<values.length-1; n++){

      if(values[n]<=values[n+1]){
        score++;
      }

    }

  }

  var ec=1;

  function gnomeSort(n, arr){

    let i = 0;
    
    while(i<n){

      if(i==0 || arr[i-1]<=arr[i]){
        
        i++;

      }
      else {
        
        let tmp=arr[i];
        arr[i]=arr[i-1];
        arr[--i]=tmp;

      }

    }

  }
  function selectionSort(){

    /* a[0] to a[aLength-1] is the array to sort */
    let i;
    let j;
    // let length=limit; // initialise to a's length

    /* advance the position through the entire array */
    /*   (could do i < aLength-1 because single element is also min element) */
    for(i=0; i<limit-1; i++){

        /* find the min element in the unsorted a[i .. aLength-1] */

        /* assume the min is the first element */
        let jMin=i;

        /* test against elements after i to find the smallest */
        for(j=i+1; j<limit; j++){

            /* if this element is less, then it is the new minimum */
            if (values[j]<values[jMin]){
                /* found new minimum; remember its index */
                jMin=j;
            }

        }

        if(jMin!=i){
          swap(i, jMin);
        }

    }

  }

  function mergeSort(arr) {

    // No need to sort the array if the array only has one element or empty
    if(arr.length<=1){
      return arr;
    }

    // In order to divide the array in half, we need to figure out the middle
    const middle=floor(arr.length/2);
  
    // This is where we will be dividing the array into left and right
    const left = arr.slice(0, middle);
    const right = arr.slice(middle);
  
    // Using recursion to combine the left and right
    return merge( mergeSort(left), mergeSort(right) );

  }
  
  // Merge the two arrays: left and right
  function merge(left,right){

    let arr=[];
    let leftIndex=0;
    let rightIndex=0;
  
    // We will concatenate values into the resultArray in order
    while(leftIndex<left.length &&
          rightIndex<right.length){

      if(left[leftIndex]<right[rightIndex]){

        arr.push(left[leftIndex]);
        leftIndex++; // move left array cursor

      }
      else{
        
        arr.push(right[rightIndex]);
        rightIndex++; // move right array cursor

      }

    }
  
    // We need to concat to the resultArray because there will be one element left over after the while loop
    return arr.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));

  }

  // function bubbaSort(){

  //   ec++; //  Expansion coefficient

  //   if(ec==100){ ec=1; }
  // print(ec);
  //   function expand(){

  //     let temp=[];

  //     for(let n=0; n<limit*ec; n++){
        
  //       if(n%ec==0){ temp[n]=values[n/ec]; }
  //       else       { temp[n]=gap;        }

  //     }

  //     limit=temp.length;

  //     values=[];

  //     arrayCopy(temp,values);

  //   }
  //   function collapse(){

  //     let temp=[];
      
  //     for(let n=0; n<values.length; n++){

  //       if(values[n]!=gap){ temp.push(values[n]); }

  //     }

  //     limit=temp.length;
      
  //     values=[];

  //     arrayCopy(temp,values);

  //   }

  //   // for(let i=0; i<1; i++){

  //     // if(N==1){
  //       // expand();
  //     // }

  //     // Iterate and place values as percentage of max
  //     for(let n=1; n<limit-1; n++){

  //       N=n;

  //       index=constrain(ceil(values[N]/max*limit), 1, limit-2);
  //       // index=floor((values[n]/max)*limit);

  //       // if(values[index]==gap){

  //         if(values[N]-values[index]<0.05*max){
  //           index-=3;
            
  //           if(index<1){ index=1; }

  //         }

  //         // if(values[N]>values[N+1]){
  //           swap(N, index);
  //         // }

  //       // }

  //       N++;

  //       N%=limit;

  //       if(N==limit-2){ N==1; }
  //       if(N==0      ){ N=1;  }

  //     }

  //     // if(N==limit-1){
  //       collapse();
  //     // }

  //     calculateScore();

  //     // if(score>=0.94*limit){
  //     //   running=false;
  //     // }

  //   // }

  // };

  function bubbaSort(){

    // for(let i=0; i<1; i++){

    let temp=[];
    let factor=1;

      temp.length=1;
      
      // Iterate and place values as percentage of max
      for(let n=0; n<values.length; n++){

        index=round(values[n]);

        // print(index + " : " + round(lerp(min,max,index/limit)));

        while(temp[index+limit*factor]!=undefined){
          
          factor++;
          
          if(factor>10){
            print(factor);
          }

        }
        
        temp[index+limit*factor]=values[n];

        factor=1;

      }

      var temp2=[];

      for(let n=0; n<temp.length; n++){
        if(temp[n]!=undefined){
          temp2.push(temp[n]);
        }
      }

    arrayCopy(temp2,values);


    let limits=[];

    // Recombine groups
    for(let n=0; n<values.length; n++){

      if(values[n+1]<values[n]){

        limits.push(n);

      }

    }

    // for(let n=0; n<limits.length; n++){
      merge(values);
    // }

  running=false;

  };

  function bubbleSort(){

    var length = values.length-1;

    for(var i=0; i<length; i++){ //Number of passes    
      for(var j=0; j<(length-i-1); j++){ //Notice that j < (length - i)

        //Compare the adjacent positions
        if (values[j]>values[j+1]){

          swap(j, j+1);
  N++;

        }
      }
    }
    
  }

  // function bubbleSort(){

  //   if(running){

  //     if(values[j]>values[j+1]){
  //       swap(j, j+1);
  //     }

  //     if(j>limit-i-2){
  //       j=0;
  //       i++;
  //     }
  //     else{
  //       j++;
  //     }
      
  //   }

  // }

  function insertionSort(){

    let len = values.length;
    
    for(var i=1; i<len; i++){

      var tmp=values[i]; //Copy of the current element. 
      
      //  Check through the sorted part and compare with the number in tmp.
      //  If large, shift the number
      for(var j=i-1; j>=0 && (values[j]>tmp); j--){

        //  Shift the number
        values[j+1]=values[j];
        N++;
      }
      
      //  Insert the copied number at the correct position
      //  in sorted part.
      values[j+1]=tmp;
      
    }

  }

  function drawvalues(){
    
    let h=-1;
    let w=(width-40)/limit;
    let x=0;
    let y=400;

    noFill();
    strokeWeight(w-1);
  stroke(128);
    for(let n=0; n<limit; n++){

      // if(n%2==0){ stroke(164); }
      // else      { stroke(96);  }
      
      // if(n%2==0){ stroke(255-values[n]/height*128); }
      // else      { stroke(values[n]/height*128+64);  }
      

      if(n==0     ||
        n==limit-1){
        // stroke(255,0,0);
      }

      if(n==N){ stroke(255,  0,  0); }
      // if(n==i){ stroke(255,255,  0); }
      // if(n==j){ stroke(  0,255,  0); }

      if(values[n]>values[n+1] &&
        n<limit-1){
        stroke(192,0,0);
      }
      else{
        stroke(128);
      }

      h=values[n]+20;
      x=n*w+20;

      line(x, y-h, x, y);

    }

    strokeWeight(0.5);
    stroke(0);

      line(20,         height-values[0]-20,
          limit*w+20, height-values[limit-1]-20);

  }

  function drawCursor(){

    push();

      translate(0.5,0.5);

        noFill();
        stroke(164);
        strokeWeight(0.5);    

          line(       0, mouseY, mouseX-5, mouseY);
          line(mouseX+5, mouseY,    width, mouseY);

          line(mouseX,        0, mouseX, mouseY-5);
          line(mouseX, mouseY+5, mouseX, height);

          ellipse(mouseX,mouseY,10,10);

    pop();

  }

  function draw(){

    background(16);

  //   if(running){

  //     // loadValues();
  //     // setLimits();

  //     startTime=millis();

  //       // bubbaSort();

  //       values=mergeSort(values);

  //       // gnomeSort(limit,values);
  //       // bubbleSort();
  //       // values.reverse();

  //       // selectionSort();
  //       // bubbaSort();

  //       // values.sort((a, b) => a - b);
  //       // values.sort();
  //       // insertionSort();

  //     stopTime=millis();

  //     elapsed=stopTime-startTime;

  //     // running=false;

  //     print(values.length    + " : " +
  //        nf(startTime,1,3) + " : " +
  //        nf(stopTime, 1,3) + " : " +
  //        nf(elapsed,  1,3));

  //   }

  //   drawvalues();
  //   calculateScore();

  //   if(score>=0.99*limit){
  //     running=false;
  //   }

  //   // noStroke();
  //   // fill(128);

  //   // text(nf(startTime,1,0) + " : " +
  //   //      nf(stopTime,1,0) + " : " +
  //   //      elapsed,
  //   //      10,15);



  //   // print(counter);



  // // values.reverse();

  //   // if(counter<2){ bubbaSort();         }
  //   // else         { bubbleSort(values); }

  //   noStroke();
  //   fill(128,0,0);
  //   textSize(16);
  //   textAlign(LEFT,TOP);
    
  //     // text(values.length,20,10);

  //     text("Score: " + score + " / " + limit,20,10);
  //     text(round(score/limit*100)+"%",20,30);
  //     text(N,20,50);

    bubbaData0.draw();
    bubbaData1.draw();
    bubbaData2.draw();
    bubbaData3.draw();
    // bubbaData4.draw();
    // bubbaData5.draw();

    drawCursor();

    // print(round(frameRate()));

  }
  function mouseMoved(){

    // let i=round((mouseX-20)/((windowWidth-40)/limit));

    // print(values[i]);

  }
  function mouseClicked(){

    running=!running;

  }

}
